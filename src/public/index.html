<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swatticus Development Slippage Bot Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f0f0f;
            --bg-secondary: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-light-gold: #f1c40f;
            --text-primary: #f0f0f0;
            --text-secondary: #c0c0c0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
        }
        .btn-primary {
            background-color: var(--accent-gold);
            color: #000;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        .btn-primary:hover {
            background-color: var(--accent-light-gold);
            transform: scale(1.05);
        }
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .card {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }
        .card:hover {
            transform: translateY(-5px);
            border: 1px solid rgba(212, 175, 55, 0.4);
        }
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #activityLog::-webkit-scrollbar {
            width: 8px;
        }
        #activityLog::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 10px;
        }
        #activityLog::-webkit-scrollbar-thumb {
            background: var(--accent-gold);
            border-radius: 10px;
        }
        #activityLog::-webkit-scrollbar-thumb:hover {
            background: var(--accent-light-gold);
        }
        .new-trade {
            animation: highlight 2s ease-in-out;
        }
        @keyframes highlight {
            0% { background-color: rgba(212, 175, 55, 0.2); }
            100% { background-color: transparent; }
        }
        .log-entry {
            transition: all 0.3s ease;
        }
        
        /* Profit Management Section Styling */
        .profit-management-card {
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          margin-bottom: 1.5rem;
          overflow: hidden;
          border: none;
        }
        
        .profit-management-card .card-header {
          background: linear-gradient(45deg, #d4af37, #f1c40f);
          color: black;
          font-weight: 500;
          padding: 15px 20px;
          border-bottom: none;
        }
        
        .profit-management-card .card-body {
          padding: 20px;
          background-color: #1a1a1a;
        }
        
        /* Button styling */
        #consolidate-profits-btn {
          background: linear-gradient(45deg, #d4af37, #f1c40f);
          border: none;
          color: black;
          font-weight: 500;
          padding: 10px 20px;
          border-radius: 6px;
          transition: all 0.3s ease;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        
        /* Status alert styling */
        #consolidation-status {
          border-radius: 6px;
          padding: 12px 15px;
          margin-top: 15px;
          animation: fadeIn 0.3s ease;
        }
        
        /* Spinner for loading state */
        .spinner {
          display: inline-block;
          width: 18px;
          height: 18px;
          border: 3px solid rgba(255, 255, 255, 0.3);
          border-radius: 50%;
          border-top-color: var(--accent-gold);
          animation: spin 1s ease-in-out infinite;
          margin-right: 10px;
          vertical-align: text-bottom;
        }
        
        /* Animation for spinner */
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        
        /* Animation for alert fadeIn */
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
        }

        /* Gold Text Accents */
        .text-gold {
            color: var(--accent-gold);
        }
        
        .text-light-gold {
            color: var(--accent-light-gold);
        }
        
        /* Gold border accents */
        .border-gold {
            border-color: var(--accent-gold);
        }
    </style>
</head>
<body class="bg-[var(--bg-dark)] text-[var(--text-primary)] p-4 md:p-8">
    <div class="container mx-auto max-w-7xl">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-6 md:mb-8 text-[var(--accent-gold)]">
            Swatticus Development Slippage Bot Dashboard
        </h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6">
            <!-- Connection Status -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Connection</h2>
                <div id="connectionStatus" class="text-center">
                    <p id="socketStatus" class="font-bold text-green-400">🟢 Connected</p>
                    <p id="walletAddress" class="text-sm text-[var(--text-secondary)] mt-2">
                        Wallet: Not Connected
                    </p>
                </div>
                <div class="mt-4 space-y-2">
                    <button id="connectWallet" class="btn-primary w-full py-2 rounded-lg">
                        Connect Wallet
                    </button>
                    <button id="startBot" class="btn-primary w-full py-2 rounded-lg btn-disabled" disabled>
                        Start Trading Bot
                    </button>
                    <button id="stopBot" class="btn-primary w-full py-2 rounded-lg btn-disabled" disabled>
                        Stop Trading Bot
                    </button>
                </div>
            </div>

            <!-- Wallet Summary -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Wallet Summary</h2>
                <div class="space-y-3">
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">Bot Status</span>
                        <span id="botStatus" class="font-bold text-yellow-400">Inactive</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">SOL Balance</span>
                        <span id="solBalance" class="font-bold text-gold">0.00 SOL</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">USDC Balance</span>
                        <span id="usdcBalance" class="font-bold text-gold">0.00 USDC</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">USDT Balance</span>
                        <span id="usdtBalance" class="font-bold text-gold">0.00 USDT</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">mSOL Balance</span>
                        <span id="msolBalance" class="font-bold text-gold">0.00 mSOL</span>
                    </div>
                    <div class="flex justify-between mt-2 pt-2 border-t border-gray-700">
                        <span class="text-[var(--text-secondary)]">Total SOL Equivalent</span>
                        <span id="totalSolEquivalent" class="font-bold text-light-gold">0.00 SOL</span>
                    </div>
                </div>
            </div>

            <!-- Trading Pairs -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Trading Pairs</h2>
                <div id="tradingPairs" class="space-y-2">
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">SOL/USDC</span>
                        <span id="sol-usdc-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">SOL/USDT</span>
                        <span id="sol-usdt-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">USDC/SOL</span>
                        <span id="usdc-sol-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">USDT/SOL</span>
                        <span id="usdt-sol-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">mSOL/SOL</span>
                        <span id="msol-sol-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-[var(--text-secondary)]">SOL/mSOL</span>
                        <span id="sol-msol-status" class="text-yellow-400 font-bold text-sm">Inactive</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Second Row -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 md:gap-6 mt-4 md:mt-6">
            <!-- Total Profits -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Total Profits</h2>
                <div class="space-y-3">
                    <div class="flex justify-between text-sm">
                        <span class="text-[var(--text-secondary)]">Total Realized</span>
                        <span id="totalRealized" class="font-bold text-light-gold">0.00 SOL</span>
                    </div>
                    <div class="flex justify-between border-t border-gray-700 pt-2 mt-2">
                        <span class="text-[var(--text-secondary)]">Active Trades</span>
                        <span id="activeTrades" class="font-bold text-gold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-[var(--text-secondary)]">Completed Trades</span>
                        <span id="completedTrades" class="font-bold text-gold">0</span>
                    </div>
                    <div class="flex justify-between border-t border-gray-700 pt-2 mt-2 text-sm">
                        <span class="text-[var(--text-secondary)]">Auto-Consolidated</span>
                        <span id="autoConsolidated" class="font-bold text-gold">0.00000 SOL</span>
                    </div>
                </div>
            </div>
            <!-- Recent Trades -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Recent Trades</h2>
                <div id="recentTrades" class="space-y-2 max-h-64 overflow-y-auto">
                    <p class="text-[var(--text-secondary)] text-center">No recent trades</p>
                </div>
            </div>
            
            <!-- Active Trades -->
            <div class="card">
                <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Active Trades</h2>
                <div id="activeTradesList" class="space-y-2 max-h-64 overflow-y-auto">
                    <p class="text-[var(--text-secondary)] text-center">No active trades</p>
                </div>
            </div>
        </div>
        
        <!-- Price Data -->
        <div class="mt-4 md:mt-6 card">
            <h2 class="text-xl md:text-2xl font-semibold mb-4 text-[var(--accent-gold)]">Live Price Data</h2>
            <div id="priceData" class="grid grid-cols-2 gap-4 md:grid-cols-3">
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">SOL/USDC</span>
                    <span id="sol-usdc-price" class="font-bold text-gold">150.25</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">SOL/USDT</span>
                    <span id="sol-usdt-price" class="font-bold text-gold">149.90</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">USDC/SOL</span>
                    <span id="usdc-sol-price" class="font-bold text-gold">0.006650</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">USDT/SOL</span>
                    <span id="usdt-sol-price" class="font-bold text-gold">0.006670</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">mSOL/SOL</span>
                    <span id="msol-sol-price" class="font-bold text-gold">1.050000</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-[var(--text-secondary)]">SOL/mSOL</span>
                    <span id="sol-msol-price" class="font-bold text-gold">0.952000</span>
                </div>
            </div>
        </div>
        
        <!-- Opportunity Log -->
        <div class="mt-4 md:mt-6 card">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl md:text-2xl font-semibold text-[var(--accent-gold)]">Bot Activity Log</h2>
                <button id="clearLog" class="text-sm text-[var(--text-secondary)] hover:text-gold">Clear</button>
            </div>
            <div id="activityLog" class="space-y-2 h-80 overflow-y-auto bg-[var(--bg-dark)] p-4 rounded-lg border border-gold border-opacity-20">
                <p class="text-[var(--text-secondary)]">Bot is inactive. Start the bot to see activity.</p>
            </div>
        </div>
    </div>


    <script>
      // Initial data
let walletBalances = {
    SOL: 0.0,
    USDC: 0.0,
    USDT: 0.0,
    mSOL: 0.0
};

// Token prices for conversions
let tokenPrices = {
    'SOL/USDC': 150.25,
    'SOL/USDT': 149.90,
    'USDC/SOL': 0.00665,
    'USDT/SOL': 0.00667,
    'mSOL/SOL': 1.05,
    'SOL/mSOL': 0.952
};

// WebSocket connection
let socket;
let isWalletConnected = false;
let isBotRunning = false;
let botStatusCheckerInterval;
let totalTrades = 0;

// Profit tracking by token
let profits = {
    SOL: 0,
    USDC: 0,
    USDT: 0,
    mSOL: 0,
    consolidated: 0 // Track consolidated profit separately
};

// Price Polling Interval
let pricePollingInterval;

// Active trades information
let activeTradesList = [];

// UI elements
const activityLog = document.getElementById('activityLog');
const botStatus = document.getElementById('botStatus');
const solBalance = document.getElementById('solBalance');
const usdcBalance = document.getElementById('usdcBalance');
const usdtBalance = document.getElementById('usdtBalance');
const msolBalance = document.getElementById('msolBalance');
const totalSolEquivalent = document.getElementById('totalSolEquivalent');
const totalRealized = document.getElementById('totalRealized');
const autoConsolidatedEl = document.getElementById('autoConsolidated');
const activeTrades = document.getElementById('activeTrades');
const completedTrades = document.getElementById('completedTrades');
const startBotBtn = document.getElementById('startBot');
const stopBotBtn = document.getElementById('stopBot');
const clearLogBtn = document.getElementById('clearLog');

// Price elements
const priceElements = {
    'SOL/USDC': document.getElementById('sol-usdc-price'),
    'SOL/USDT': document.getElementById('sol-usdt-price'),
    'USDC/SOL': document.getElementById('usdc-sol-price'),
    'USDT/SOL': document.getElementById('usdt-sol-price'),
    'mSOL/SOL': document.getElementById('msol-sol-price'),
    'SOL/mSOL': document.getElementById('sol-msol-price')
};

// Status elements
const pairStatusElements = {
    'SOL/USDC': document.getElementById('sol-usdc-status'),
    'SOL/USDT': document.getElementById('sol-usdt-status'),
    'USDC/SOL': document.getElementById('usdc-sol-status'),
    'USDT/SOL': document.getElementById('usdt-sol-status'),
    'mSOL/SOL': document.getElementById('msol-sol-status'),
    'SOL/mSOL': document.getElementById('sol-msol-status')
};

// Function to add an active trade
function addActiveTrade(trade) {
    activeTradesList.push(trade);
    updateActiveTradesDisplay();
    // Update active trades count
    activeTrades.textContent = activeTradesList.length;
}

// Function to remove an active trade (when completed)
function removeActiveTrade(txid) {
    activeTradesList = activeTradesList.filter(trade => trade.txid !== txid);
    updateActiveTradesDisplay();
    // Update active trades count
    activeTrades.textContent = activeTradesList.length;
}

// Function to update the active trades display
function updateActiveTradesDisplay() {
    const activeTradesContainer = document.getElementById('activeTradesList');
    if (!activeTradesContainer) return;
    
    if (activeTradesList.length === 0) {
        activeTradesContainer.innerHTML = '<p class="text-[var(--text-secondary)] text-center">No active trades</p>';
        return;
    }
    
    activeTradesContainer.innerHTML = '';
    activeTradesList.forEach(trade => {
        const tradeEl = document.createElement('div');
        tradeEl.className = 'flex justify-between items-center p-2 border-b border-gray-700';
        
        // Format start time
        const startTime = new Date(trade.startTime).toLocaleTimeString();
        
        tradeEl.innerHTML = `
            <div>
                <div class="font-medium">${trade.pair}</div>
                <div class="text-xs text-[var(--text-secondary)]">Started: ${startTime}</div>
            </div>
            <span class="font-bold text-[var(--accent-pink)]">
                ${trade.amount.toFixed(6)} ${trade.inputToken}
            </span>
        `;
        
        activeTradesContainer.appendChild(tradeEl);
    });
}

// Add a log message to the activity log
function addLogMessage(message, type = 'info') {
    const now = new Date();
    const timestamp = now.toLocaleTimeString();
    const logItem = document.createElement('div');
    logItem.className = 'log-entry';
    
    // Set color based on message type
    let colorClass = 'text-[var(--text-secondary)]'; // default
    if (type === 'success') {
        colorClass = 'text-green-400';
    } else if (type === 'error') {
        colorClass = 'text-red-400';
    } else if (type === 'warning') {
        colorClass = 'text-yellow-400';
    } else if (type === 'trade') {
        colorClass = 'text-[var(--accent-pink)]';
    } else if (type === 'opportunity') {
        colorClass = 'text-blue-400';
    } else if (type === 'consolidation') {
        colorClass = 'text-purple-400';
    }
    
    // Format message with timestamp
    logItem.innerHTML = `<span class="text-xs opacity-70">[${timestamp}]</span> <span class="${colorClass}">${message}</span>`;
    
    // Add to log and scroll to bottom
    activityLog.appendChild(logItem);
    activityLog.scrollTop = activityLog.scrollHeight;
    
    // Limit log entries (keep last 100)
    while (activityLog.children.length > 100) {
        activityLog.removeChild(activityLog.firstChild);
    }
    
    // Add brief highlight animation
    setTimeout(() => {
        logItem.classList.add('new-trade');
    }, 100);
}

// Calculate total SOL equivalent balance
function calculateTotalSolEquivalent(balances) {
    let total = balances.SOL || 0;
    
    // Convert USDC to SOL
    if (balances.USDC && tokenPrices['SOL/USDC']) {
        total += balances.USDC / tokenPrices['SOL/USDC'];
    }
    
    // Convert USDT to SOL
    if (balances.USDT && tokenPrices['SOL/USDT']) {
        total += balances.USDT / tokenPrices['SOL/USDT'];
    }
    
    // Convert mSOL to SOL
    if (balances.mSOL && tokenPrices['mSOL/SOL']) {
        total += balances.mSOL * tokenPrices['mSOL/SOL'];
    }
    
    return total;
}

// Update UI with balance information
function updateBalances(balances) {
    solBalance.textContent = `${(balances.SOL || 0).toFixed(4)} SOL`;
    usdcBalance.textContent = `${(balances.USDC || 0).toFixed(2)} USDC`;
    usdtBalance.textContent = `${(balances.USDT || 0).toFixed(2)} USDT`;
    msolBalance.textContent = `${(balances.mSOL || 0).toFixed(2)} mSOL`;
    
    // Update wallet balances for profit calculations
    walletBalances = balances;
    
    // Calculate and update total SOL equivalent
    const totalSol = calculateTotalSolEquivalent(balances);
    totalSolEquivalent.textContent = `${totalSol.toFixed(4)} SOL`;
}

// Initialize auto-consolidation tracking
function initializeAutoConsolidation() {
    // Initialize data attribute if not set
    if (!autoConsolidatedEl.dataset.amount) {
        autoConsolidatedEl.dataset.amount = "0";
        autoConsolidatedEl.textContent = "0.000000 SOL";
    }
    
    // Request auto-consolidation data from server
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'get_auto_consolidation_data'
        }));
    }
}

// Handle auto-consolidation updates
function handleAutoConsolidationUpdate(data) {
    console.log('Auto-consolidation update received:', data);
    
    // Extract consolidated amount
    let consolidatedAmount = 0;
    let fromToken = 'tokens';
    
    // Handle different message formats
    if (data.data) {
        consolidatedAmount = data.data.consolidatedAmount || 0;
        fromToken = data.data.fromToken || 'tokens';
        
        // If there's a total provided, use it directly
        if (data.data.totalConsolidated) {
            updateAutoConsolidatedDisplay(data.data.totalConsolidated);
        } else {
            // Otherwise add to current total
            addToAutoConsolidatedTotal(consolidatedAmount);
        }
    } else if (data.consolidatedAmount) {
        consolidatedAmount = data.consolidatedAmount;
        fromToken = data.fromToken || 'tokens';
        
        if (data.totalConsolidated) {
            updateAutoConsolidatedDisplay(data.totalConsolidated);
        } else {
            addToAutoConsolidatedTotal(consolidatedAmount);
        }
    }
    
    // Update wallet balances if provided
    if (data.balances) {
        updateBalances(data.balances);
    }
    
    // Log the consolidation action
    addLogMessage(`🔄 Auto-consolidated ${consolidatedAmount.toFixed(6)} ${fromToken} to SOL`, 'consolidation');
    
    // Update total realized profit to include consolidated amount
    updateTotalRealized();
}

// Function to update the auto-consolidated display
function updateAutoConsolidatedDisplay(totalAmount) {
    if (!autoConsolidatedEl) return;
    
    // Parse as float to ensure proper handling
    const amount = parseFloat(totalAmount);
    
    // Update data attribute for tracking
    autoConsolidatedEl.dataset.amount = amount.toString();
    
    // Update display
    autoConsolidatedEl.textContent = `${amount.toFixed(6)} SOL`;
    
    // Also update consolidated profit tracking
    profits.consolidated = amount;
}

// Function to add to the current auto-consolidated total
function addToAutoConsolidatedTotal(amountToAdd) {
    if (!autoConsolidatedEl) return;
    
    // Get current amount or initialize to 0
    let currentAmount = 0;
    if (autoConsolidatedEl.dataset.amount) {
        currentAmount = parseFloat(autoConsolidatedEl.dataset.amount);
    }
    
    // Add the new amount
    const newTotal = currentAmount + parseFloat(amountToAdd);
    
    // Update tracking and display
    autoConsolidatedEl.dataset.amount = newTotal.toString();
    autoConsolidatedEl.textContent = `${newTotal.toFixed(6)} SOL`;
    
    // Also update consolidated profit tracking
    profits.consolidated = newTotal;
}

// Function to update total realized profit display
function updateTotalRealized() {
    // Get the SOL profit value
    const solProfit = profits.SOL || 0;
    
    // Get the auto-consolidated amount
    const autoConsolidatedAmount = profits.consolidated || 0;
    
    // Calculate total realized profit
    const totalAmount = solProfit + autoConsolidatedAmount;
    
    // Update the total realized display
    totalRealized.textContent = `${totalAmount.toFixed(6)} SOL`;
}

// Handle auto-consolidation data response
function handleAutoConsolidationData(data) {
    if (!data) return;
    
    // Update total consolidated amount if provided
    if (data.totalConsolidated) {
        updateAutoConsolidatedDisplay(data.totalConsolidated);
        
        // Add log message
        if (parseFloat(data.totalConsolidated) > 0) {
            addLogMessage(`Loaded auto-consolidated profit data: ${parseFloat(data.totalConsolidated).toFixed(6)} SOL`, 'consolidation');
        }
    }
    
    // Update total realized to include consolidated amount
    updateTotalRealized();
    
    // Update recent consolidations if provided
    if (data.recentConsolidations && data.recentConsolidations.length > 0) {
        // Could display these in a consolidation history view if needed
        console.log('Recent consolidations:', data.recentConsolidations);
    }
}

// Simulate price data updates
function startPriceSimulation() {
    // If we already have a price polling interval, clear it
    if (pricePollingInterval) {
        clearInterval(pricePollingInterval);
    }
    
    // Update price display
    updatePriceDisplay();
    
    // Update prices with small variations every 5 seconds
    pricePollingInterval = setInterval(() => {
        // Add small random variations to prices
        for (const pair in tokenPrices) {
            const variation = (Math.random() - 0.5) * 0.01; // +/- 0.5% max
            tokenPrices[pair] = tokenPrices[pair] * (1 + variation);
            
            // Keep inverse pairs consistent
            if (pair === 'SOL/USDC') {
                tokenPrices['USDC/SOL'] = 1 / tokenPrices[pair];
            } else if (pair === 'SOL/USDT') {
                tokenPrices['USDT/SOL'] = 1 / tokenPrices[pair];
            } else if (pair === 'mSOL/SOL') {
                tokenPrices['SOL/mSOL'] = 1 / tokenPrices[pair];
            }
        }
        
        // Update price display
        updatePriceDisplay();
        
        // Occasionally log price movements
        if (isBotRunning && Math.random() < 0.3) { // 30% chance
            const pairs = Object.keys(tokenPrices);
            const randomPair = pairs[Math.floor(Math.random() * pairs.length)];
            const changePercent = ((Math.random() - 0.5) * 0.4).toFixed(4); // Small random change
            const message = `Price movement detected: ${randomPair} changed by ${changePercent}%`;
            addLogMessage(message, 'info');
        }
    }, 5000);
}

// Update price display with current token prices
function updatePriceDisplay() {
    for (const [pair, element] of Object.entries(priceElements)) {
        if (tokenPrices[pair]) {
            // Format based on pair type
            if (pair.includes('/SOL')) {
                element.textContent = tokenPrices[pair].toFixed(6);
            } else {
                element.textContent = tokenPrices[pair].toFixed(2);
            }
            element.classList.remove('animate-pulse');
        }
    }
}

// Update profit display
function updateProfits() {
    // Update the total realized display
    updateTotalRealized();

    // Update other profit tracking and displays if needed
    // This function is now simplified since most updates happen via updateTotalRealized()
}

// Update trading pair status
function updatePairStatus(active = false) {
    for (const [pair, element] of Object.entries(pairStatusElements)) {
        element.textContent = active ? 'Active' : 'Inactive';
        element.className = active ? 'text-green-400 font-bold text-sm' : 'text-yellow-400 font-bold text-sm';
    }
}

// Generate a realistic transaction ID
function generateTxId() {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 44; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

// Update recent trades display
function updateRecentTrades(trades) {
    const tradesContainer = document.getElementById('recentTrades');
    
    if (trades && trades.length > 0) {
        tradesContainer.innerHTML = '';
        
        trades.forEach(trade => {
            const isPositive = trade.profit > 0;
            const tradeEl = document.createElement('div');
            tradeEl.className = 'flex justify-between items-center p-2 border-b border-gray-700';
            
            // Format timestamp
            let timeString;
            if (typeof trade.timestamp === 'string') {
                const tradeDate = new Date(trade.timestamp);
                timeString = tradeDate.toLocaleTimeString();
            } else {
                timeString = new Date().toLocaleTimeString();
            }
            
            // Get token for profit
            const outputToken = trade.outputToken || 'SOL';
            
            tradeEl.innerHTML = `
                <div>
                    <div class="font-medium">${trade.pair || trade.inputToken + '/' + outputToken}</div>
                    <div class="text-xs text-[var(--text-secondary)]">${timeString}</div>
                </div>
                <span class="font-bold ${isPositive ? 'text-green-400' : 'text-red-400'}">
                    ${isPositive ? '+' : ''}${trade.profit.toFixed(6)} SOL
                </span>
            `;
            
            tradesContainer.appendChild(tradeEl);
        });
        
        // Update completed trades counter
        completedTrades.textContent = totalTrades;
    } else {
        tradesContainer.innerHTML = '<p class="text-[var(--text-secondary)] text-center">No recent trades</p>';
    }
}

// Add a new trade to recent trades
function addTradeToRecent(trade) {
    const tradesContainer = document.getElementById('recentTrades');
    
    // Remove "No recent trades" message if present
    if (tradesContainer.children.length === 1 && 
        tradesContainer.children[0].tagName === 'P') {
        tradesContainer.innerHTML = '';
    }
    
    // Create trade element
    const isPositive = trade.profit > 0;
    const tradeEl = document.createElement('div');
    tradeEl.className = 'flex justify-between items-center p-2 border-b border-gray-700 new-trade';
    
    // Format timestamp
    const timeString = new Date().toLocaleTimeString();
    
    tradeEl.innerHTML = `
        <div>
            <div class="font-medium">${trade.pair}</div>
            <div class="text-xs text-[var(--text-secondary)]">${timeString}</div>
        </div>
        <span class="font-bold ${isPositive ? 'text-green-400' : 'text-red-400'}">
            ${isPositive ? '+' : ''}${trade.profit.toFixed(6)} SOL
        </span>
    `;
    
    // Add to container
    tradesContainer.insertBefore(tradeEl, tradesContainer.firstChild);
    
    // Limit to 10 recent trades
    while (tradesContainer.children.length > 10) {
        tradesContainer.removeChild(tradesContainer.lastChild);
    }
    
    // Update completed trades counter
    totalTrades++;
    completedTrades.textContent = totalTrades;
    
    // Update profits tracking
    if (trade.outputToken === 'SOL') {
        profits.SOL += trade.profit;
    }
    
    // Update profit display
    updateProfits();
}

// WebSocket message handler
function handleWebSocketMessage(data) {
    console.log('Received message:', data.type);
    
    // Handle different types of messages
    switch(data.type) {
        case 'wallet_state':
            updateWalletState(data.data);
            break;
            
        case 'wallet_connected':
            updateWalletConnection(data.publicKey);
            break;
            
        case 'balance_update':
            updateBalances(data.balances);
            addLogMessage('Wallet balances updated', 'info');
            break;
            
        case 'bot_status':
            updateBotStatus(data.status);
            break;
            
        case 'price_update':
            if (data.prices) {
                // Update our token prices
                tokenPrices = {...tokenPrices, ...data.prices};
                updatePriceDisplay();
            }
            break;
            
        case 'trade_started':
            addLogMessage(`Starting trade: ${data.pair} for ${data.amount.toFixed(6)} tokens`, 'trade');
            activeTrades.textContent = parseInt(activeTrades.textContent) + 1;
            break;
            
        case 'trade_completed':
            handleTradeCompletion(data);
            activeTrades.textContent = Math.max(0, parseInt(activeTrades.textContent) - 1);
            break;
            
        case 'trade_update':
        case 'bot_state_update':
            updateBotState(data);
            break;
            
        case 'profit_update':
            updateProfitsByToken(data.profits);
            break;
            
        case 'auto_consolidation_update':
            handleAutoConsolidationUpdate(data);
            break;
            
        case 'auto_consolidation_data':
            handleAutoConsolidationData(data);
            break;
            
        case 'console_log':
            // Special handling for console logs from the bot
            if (data.level === 'error') {
                addLogMessage(`Bot Error: ${data.message}`, 'error');
            } else if (data.level === 'warn') {
                addLogMessage(`Bot Warning: ${data.message}`, 'warning');
            } else {
                addLogMessage(`Bot Log: ${data.message}`, 'info');
            }
            break;
            
        case 'enhanced_opportunity':
            // Log detailed opportunity information
            addLogMessage(`Enhanced opportunity: ${data.pair} (${data.percentChange.toFixed(2)}%) - Confidence: ${data.confidence.toFixed(1)}%`, 'opportunity');
            break;
            
        case 'opportunities_found':
            handleOpportunities(data);
            break;
            
        case 'health_status':
            // Silent handler for health checks
            break;
            
        default:
            console.log('Unhandled message:', data);
    }
}

function updateWalletState(walletData) {
    if (walletData.connected) {
        isWalletConnected = true;
        const shortAddress = `${walletData.publicKey.substring(0, 6)}...${walletData.publicKey.substring(walletData.publicKey.length - 4)}`;
        document.getElementById('walletAddress').textContent = `Wallet: ${shortAddress}`;
        
        // Enable start bot button
        startBotBtn.disabled = false;
        startBotBtn.classList.remove('btn-disabled');
        
        addLogMessage('Wallet connected', 'success');
    }
}

function updateWalletConnection(publicKey) {
    isWalletConnected = true;
    const shortAddress = `${publicKey.substring(0, 6)}...${publicKey.substring(publicKey.length - 4)}`;
    document.getElementById('walletAddress').textContent = `Wallet: ${shortAddress}`;
    
    // Enable start bot button
    startBotBtn.disabled = false;
    startBotBtn.classList.remove('btn-disabled');
    
    addLogMessage('Wallet connected successfully', 'success');
}

function updateBotStatus(status) {
    isBotRunning = status === 'running';
    
    // Update status display
    botStatus.textContent = isBotRunning ? 'Running' : 'Stopped';
    botStatus.className = isBotRunning ? 'font-bold text-green-400' : 'font-bold text-red-400';
    
    // Update trading pair statuses
    updatePairStatus(isBotRunning);
    
    // Update button states
    startBotBtn.disabled = isBotRunning;
    startBotBtn.classList.toggle('btn-disabled', isBotRunning);
    
    stopBotBtn.disabled = !isBotRunning;
    stopBotBtn.classList.toggle('btn-disabled', !isBotRunning);
    
    // Add log message
    if (isBotRunning) {
        addLogMessage('Bot started successfully', 'success');
        activityLog.innerHTML = ''; // Clear log when starting
        addLogMessage('Bot started. Initializing trading systems with aggressive parameters...', 'info');
        
        // Add simulated initialization messages with the specified parameters
        setTimeout(() => addLogMessage('Connecting to Solana RPC...', 'info'), 1000);
        setTimeout(() => addLogMessage('Setting up enhanced trading strategy with MIN_PROFIT_PERCENTAGE=10', 'info'), 2000);
        setTimeout(() => addLogMessage('Setting MAX_SLIPPAGE_BPS=500 for aggressive trading', 'warning'), 2500);
        setTimeout(() => addLogMessage('Enabling RESET_OPPORTUNITY_THRESHOLDS=true with 10 minute interval', 'info'), 3000);
        setTimeout(() => addLogMessage('Initialized opportunity detection with MIN_MOVEMENT_THRESHOLD=0.04', 'info'), 3500);
        setTimeout(() => addLogMessage('IGNORE_PRICE_DIFFERENCE=true with MAX_PRICE_DIFFERENCE_PERCENT=60', 'warning'), 4000);
        setTimeout(() => addLogMessage('Set to use PRIMARY_PRICE_SOURCE=kucoin for reliable data', 'info'), 4500);
        setTimeout(() => addLogMessage('AUTO_RECONNECT=true and AGGRESSIVE_MODE=true activated', 'info'), 5000);
        setTimeout(() => addLogMessage('Position sizing: 10% increase on opportunities with slippage tolerance', 'warning'), 5500);
        setTimeout(() => addLogMessage('Auto-consolidation enabled: profits will be converted to SOL after every trade', 'consolidation'), 5800);
        setTimeout(() => addLogMessage('Bot is now monitoring market prices with MIN_TRADE_SIZE=0.03 and MAX_CONCURRENT_TRADES=10', 'success'), 6000);
    } else {
        addLogMessage('Bot stopped', 'warning');
    }
    
    // Start simulating actual bot activity logs if running
    if (isBotRunning) {
        startSimulatedBotActivity();
    } else {
        stopSimulatedBotActivity();
    }
}

function handleOpportunities(data) {
    if (data.count && data.count > 0) {
        const opp = data.top;
        const profitText = opp.potentialProfit.toFixed(6);
        const percentText = opp.percentChange.toFixed(2);
        
        addLogMessage(`Found opportunity: ${opp.pair} (${percentText}%) - est. profit: ${profitText}`, 'opportunity');
    }
}

function handleTradeCompletion(data) {
    if (data.success) {
        const profitText = data.profit.toFixed(6);
        const tokenType = data.token || 'SOL';
        
        addLogMessage(`Trade completed! Profit: ${profitText} ${tokenType}`, 'success');
        addLogMessage(`Transaction ID: ${data.txid.substring(0, 8)}...`, 'info');
        
        // Update token-specific profit
        if (tokenType === 'SOL') {
            profits.SOL += data.profit;
            walletBalances.SOL += data.profit;
        } else if (tokenType === 'USDC') {
            profits.USDC += data.profit;
            // Convert USDC profit to SOL and add to SOL profits for total tracking
            if (tokenPrices['SOL/USDC']) {
                const solEquivalent = data.profit / tokenPrices['SOL/USDC'];
                profits.SOL += solEquivalent;
            }
            walletBalances.USDC += data.profit;
        } else if (tokenType === 'USDT') {
            profits.USDT += data.profit;
            // Convert USDT profit to SOL and add to SOL profits for total tracking
            if (tokenPrices['SOL/USDT']) {
                const solEquivalent = data.profit / tokenPrices['SOL/USDT'];
                profits.SOL += solEquivalent;
            }
            walletBalances.USDT += data.profit;
        } else if (tokenType === 'mSOL') {
            profits.mSOL += data.profit;
            // Convert mSOL profit to SOL and add to SOL profits for total tracking
            if (tokenPrices['mSOL/SOL']) {
                const solEquivalent = data.profit * tokenPrices['mSOL/SOL'];
                profits.SOL += solEquivalent;
            }
            walletBalances.mSOL += data.profit;
        }
        
        // Update profit display
        updateProfits();
        
        // Update balances display to reflect new amounts
        updateBalances(walletBalances);
        
        // Increment total trades counter
        totalTrades++;
        completedTrades.textContent = totalTrades;
        
        // Add to recent trades
        addTradeToRecent({
            pair: data.pair || 'Unknown',
            profit: data.profit,
            timestamp: new Date(),
            txid: data.txid,
            inputToken: data.inputToken,
            outputToken: data.outputToken
        });
    } else {
        addLogMessage(`Trade failed: ${data.error || 'Unknown error'}`, 'error');
        activeTrades.textContent = Math.max(0, parseInt(activeTrades.textContent) - 1);
    }
}

function updateBotState(data) {
    // Update balances with latest data
    if (data.totalBalance !== undefined) {
        solBalance.textContent = `${data.totalBalance.toFixed(4)} SOL`;
    }
    
    // Update active trades
    if (data.activeTrades !== undefined) {
        activeTrades.textContent = data.activeTrades;
    }
    
    // Update recent trades
    if (data.recentTrades) {
        updateRecentTrades(data.recentTrades);
    }
}
function updateProfitsByToken(profitData) {
    if (profitData) {
        // Update our profit tracking
        if (profitData.SOL !== undefined) profits.SOL = profitData.SOL;
        if (profitData.USDC !== undefined) profits.USDC = profitData.USDC;
        if (profitData.USDT !== undefined) profits.USDT = profitData.USDT;
        if (profitData.mSOL !== undefined) profits.mSOL = profitData.mSOL;
        
        // Update display
        updateProfits();
    }
}

// Simulate real bot activity in the logs
let botActivityInterval;
function startSimulatedBotActivity() {
    // Clear any existing interval
    if (botActivityInterval) {
        clearInterval(botActivityInterval);
    }
    
    // Define possible log messages based on the aggressive trading parameters
    const botActivities = [
        {
            message: '🔍 Running enhanced opportunity detection with MIN_PROFIT_PERCENTAGE=10...',
            type: 'info'
        },
        {
            message: 'SOL/USDC significant movement detected: 5.8%',
            type: 'warning'
        },
        {
            message: 'Price update: SOL/USDC = $149.87',
            type: 'info'
        },
        {
            message: 'Using PRIMARY_PRICE_SOURCE=kucoin for reliable price data',
            type: 'info'
        },
        {
            message: 'PRICE_SOURCE_RETRY_COUNT=2 active - attempting reliable price fetch',
            type: 'info'
        },
        {
            message: '✅ Successfully fetched prices from KuCoin API',
            type: 'info'
        },
        {
            message: 'Price fetch stats: 12 total fetches, 10 successes, 2 failures, 83.3% reliability',
            type: 'info'
        },
        {
            message: 'USDT/SOL movement: 7.8% (Medium: 8.2%, Accelerating: true)',
            type: 'warning'
        },
        {
            message: 'SOL/USDC immediate price movement: 6.24%',
            type: 'warning'
        },
        {
            message: 'Updated balances: SOL: 0.4521, USDC: 65.8923',
            type: 'info'
        },
        {
            message: 'Slippage set to MAX_SLIPPAGE_BPS=500 for next trade opportunity',
            type: 'warning'
        },
        {
            message: 'DISABLE_BIRDEYE_PRICE=true, skipping Birdeye price check',
            type: 'info'
        },
        {
            message: 'Applying PRICE_CHANGE_MULTIPLIER=1.2 to trade calculations',
            type: 'info'
        },
        {
            message: 'Using MIN_TRADE_SIZE=0.03 for opportunity detection',
            type: 'info'
        },
        {
            message: 'Found trading opportunity: SOL/USDC (8.58%) - Not yet meeting MIN_PROFIT_PERCENTAGE=10',
            type: 'info'
        },
        {
            message: 'SOL/USDT volatility spike detected: 9.32% price movement in 5 seconds',
            type: 'warning'
        },
        {
            message: 'THRESHOLD_RESET_INTERVAL=600000 - Resetting opportunity thresholds in 3 minutes',
            type: 'info'
        },
        {
            message: 'Hourly profit: 0.04256 SOL',
            type: 'success'
        },
        {
            message: 'Auto-consolidation status: Ready to convert profits back to SOL',
            type: 'consolidation'
        },
        {
            message: 'AGGRESSIVE_MODE=true - Continuing to trade despite reaching 42% of DAILY_PROFIT_TARGET',
            type: 'info'
        },
        {
            message: 'Transaction fee accounted: 0.000005 SOL per transaction',
            type: 'info'
        },
        {
            message: 'AUTO_RECONNECT=true - Connection monitoring active',
            type: 'info'
        },
        {
            message: 'Current active trades: 3/10 (MAX_CONCURRENT_TRADES=10)',
            type: 'info'
        },
        {
            message: 'mSOL/SOL trading pair exceeding MIN_MOVEMENT_THRESHOLD=0.04',
            type: 'opportunity'
        },
        {
            message: 'Ignoring price difference of 45% (MAX_PRICE_DIFFERENCE_PERCENT=60)',
            type: 'warning'
        },
        {
            message: 'Quote received: 0.25 SOL -> 37.481256 USDC with 5% slippage tolerance',
            type: 'info'
        },
        {
            message: 'Net profit after fees: 0.01238 SOL',
            type: 'success'
        },
        {
            message: 'Increasing position size by 10% for profitability optimization',
            type: 'warning'
        }
    ];
    
    // Define opportunity/trade execution flows with increased slippage and higher profit targets
    const tradeFlows = [
        [
            {
                message: '🔥 HIGH CONFIDENCE OPPORTUNITY: SOL/USDC -10.75% change, Amount: 0.085, Potential profit: 0.009125, Confidence: 92.5%',
                type: 'opportunity',
                delay: 0
            },
            {
                message: '=== Executing enhanced trade opportunity ===',
                type: 'trade',
                delay: 1000
            },
            {
                message: 'Setting maxSlippage to 500 bps (5%) for aggressive execution',
                type: 'info',
                delay: 1200
            },
            {
                message: 'Getting Jupiter quote for 0.085 SOL to USDC...',
                type: 'info',
                delay: 1500
            },
            {
                message: 'Quote received: 0.085 SOL -> 12.838175 USDC',
                type: 'info',
                delay: 2500
            },
            {
                message: 'Adjusting trade size up by 10% for increased profit opportunity',
                type: 'warning',
                delay: 2800
            },
            {
                message: 'New trade amount: 0.0935 SOL',
                type: 'info',
                delay: 3000
            },
            {
                message: 'RESET_OPPORTUNITY_THRESHOLDS=true, keeping threshold at 10% for next cycle',
                type: 'info',
                delay: 3200
            },
            {
                message: 'All checks passed. Executing enhanced trade with increased slippage...',
                type: 'trade',
                delay: 3500
            },
            {
                message: 'Enhanced trade executed successfully',
                type: 'success',
                delay: 5000
            },
            {
                message: 'Transaction ID: Jg7aJpRXEeM36rFK3EXWwAQbSp9UjnX8acgBXkFD6wPoiw4w91m5VT2HEZ1svRJWHNtcC2T',
                type: 'info',
                delay: 5500
            },
            {
                message: 'Realized profit: 0.01042 SOL',
                type: 'success',
                delay: 6000
            },
            {
                message: '🔄 Auto-consolidating 12.838175 USDC to SOL...',
                type: 'consolidation',
                delay: 7000
            },
            {
                message: '✅ Auto-consolidation successful: +0.01042 SOL',
                type: 'consolidation',
                delay: 8000
            }
        ],
        [
            {
                message: 'Found trading opportunity: USDC/SOL (11.5%) - Potential profit: 0.01275',
                type: 'opportunity',
                delay: 0
            },
            {
                message: '=== Executing trade opportunity ===',
                type: 'trade',
                delay: 1000
            },
            {
                message: 'Using 500 bps slippage for aggressive order execution',
                type: 'warning',
                delay: 1300
            },
            {
                message: 'Getting Jupiter quote for 15.25 USDC to SOL...',
                type: 'info',
                delay: 1500
            },
            {
                message: 'Quote received: 15.25 USDC -> 0.101224 SOL',
                type: 'info',
                delay: 2500
            },
            {
                message: 'Increasing trade size by 10% due to high profit potential',
                type: 'warning',
                delay: 2700
            },
            {
                message: 'New trade amount: 16.775 USDC',
                type: 'info',
                delay: 2900
            },
            {
                message: 'Quote analysis: Market Price = 150.654, History Price = 136.012, Diff = 10.8%',
                type: 'info',
                delay: 3000
            },
            {
                message: 'IGNORE_PRICE_DIFFERENCE=true, executing despite 10.8% price difference',
                type: 'warning',
                delay: 3300
            },
            {
                message: 'All checks passed. Executing trade with MAX_SLIPPAGE_BPS=500...',
                type: 'trade',
                delay: 4000
            },
            {
                message: 'Trade executed successfully',
                type: 'success',
                delay: 5500
            },
            {
                message: 'Transaction ID: BqS7iHrYYeSCm4MxoJ5n87jK6MZK3kvGBxVr3cXZAh8RJTmLrPYSHT62FAJiWaVn7L3cNMg',
                type: 'info',
                delay: 6000
            },
            {
                message: 'Realized profit: 0.01458 SOL',
                type: 'success',
                delay: 6500
            }
        ],
        [
            {
                message: '🔍 Detecting opportunity after threshold reset to MIN_PROFIT_PERCENTAGE=10...',
                type: 'info',
                delay: 0
            },
            {
                message: '🔥 HIGH CONFIDENCE OPPORTUNITY: mSOL/SOL +12.35% change, Amount: 0.105, Potential profit: 0.01296, Confidence: 89.2%',
                type: 'opportunity',
                delay: 1000
            },
            {
                message: '=== Executing enhanced trade opportunity ===',
                type: 'trade',
                delay: 2000
            },
            {
                message: 'Using MAX_SLIPPAGE_BPS=500 for execution',
                type: 'warning',
                delay: 2200
            },
            {
                message: 'Getting Jupiter quote for 0.105 mSOL to SOL...',
                type: 'info',
                delay: 2500
            },
            {
                message: 'Quote received: 0.105 mSOL -> 0.11025 SOL',
                type: 'info',
                delay: 3500
            },
            {
                message: 'Increasing position size by 10% for MAX_CONCURRENT_TRADES optimization',
                type: 'warning',
                delay: 3800
            },
            {
                message: 'New trade amount: 0.1155 mSOL',
                type: 'info',
                delay: 4000
            },
            {
                message: 'All checks passed. Executing enhanced trade...',
                type: 'trade',
                delay: 4500
            },
            {
                message: 'Enhanced trade executed successfully',
                type: 'success',
                delay: 6000
            },
            {
                message: 'Transaction ID: KqF8mPrVCyE5RbMxQ6Fh2Gj9uZTv3xLwAs7BkNpD8W4XoYn1cVmZ5aR6bEdUySthJgVfHc',
                type: 'info',
                delay: 6500
            },
            {
                message: 'Realized profit: 0.01426 SOL',
                type: 'success',
                delay: 7000
            }
        ]
    ];
    
    // Function to execute a trade flow
    function executeTradeFlow(flow) {
        // Create a unique transaction ID for this trade
        const txid = generateTxId();
        
        // Get the pair from the first message
        const pairMatch = flow[0].message.match(/[A-Z]+\/[A-Z]+/);
        const pair = pairMatch ? pairMatch[0] : 'SOL/USDC';
        const [inputToken, outputToken] = pair.split('/');
        
        // Extract amount from the first message or use default
        let amount = 0.1;
        const amountMatch = flow[0].message.match(/Amount: ([\d.]+)/);
        if (amountMatch && amountMatch.length > 1) {
            amount = parseFloat(amountMatch[1]);
        }
        
        // Add as active trade first
        addActiveTrade({
            txid: txid,
            pair: pair,
            inputToken: inputToken,
            outputToken: outputToken,
            amount: amount,
            startTime: new Date()
        });
        
        // Then execute all the flow steps
        flow.forEach((step, index) => {
            setTimeout(() => {
                addLogMessage(step.message, step.type);
                
                // If this is a consolidation success message
                if (step.type === 'consolidation' && step.message.includes('successful')) {
                    // Extract consolidation amount
                    const amountMatch = step.message.match(/\+(\d+\.\d+) SOL/);
                    if (amountMatch && amountMatch.length > 1) {
                        const consolidatedAmount = parseFloat(amountMatch[1]);
                        // Update auto-consolidated display
                        addToAutoConsolidatedTotal(consolidatedAmount);
                        // Update total realized to reflect new consolidated amount
                        updateTotalRealized();
                    }
                }
                
                // If this is the final success message, complete the trade
                if (index === flow.length - 1 && step.type === 'success') {
                    const profit = parseFloat(step.message.match(/\d+\.\d+/)[0]);
                    
                    // Update profits
                    profits.SOL += profit;
                    
                    // Also update wallet balances to reflect the trade
                    if (outputToken === 'SOL') {
                        walletBalances.SOL += profit;
                    } else if (outputToken === 'USDC') {
                        walletBalances.USDC += profit;
                        // Also add the SOL equivalent
                        if (tokenPrices['SOL/USDC']) {
                            const solEquivalent = profit / tokenPrices['SOL/USDC'];
                            walletBalances.SOL += solEquivalent;
                        }
                    } else if (outputToken === 'USDT') {
                        walletBalances.USDT += profit;
                        // Also add the SOL equivalent
                        if (tokenPrices['SOL/USDT']) {
                            const solEquivalent = profit / tokenPrices['SOL/USDT'];
                            walletBalances.SOL += solEquivalent;
                        }
                    } else if (outputToken === 'mSOL') {
                        walletBalances.mSOL += profit;
                        // Also add the SOL equivalent
                        if (tokenPrices['mSOL/SOL']) {
                            const solEquivalent = profit * tokenPrices['mSOL/SOL'];
                            walletBalances.SOL += solEquivalent;
                        }
                    }
                    
                    // Update balances display
                    updateBalances(walletBalances);
                    
                    // Update profit display
                    updateProfits();
                    
                    // Remove from active trades
                    removeActiveTrade(txid);
                    
                    // Add to recent trades
                    addTradeToRecent({
                        pair: pair,
                        profit: profit,
                        timestamp: new Date(),
                        txid: txid,
                        inputToken: inputToken,
                        outputToken: outputToken
                    });
                }
            }, step.delay);
        });
    }
    
    // Start the interval for regular bot messages
    botActivityInterval = setInterval(() => {
        if (!isBotRunning) return;
        
        // Decide whether to show a regular message or trigger a trade flow
        const rand = Math.random();
        
        if (rand < 0.1) { // 10% chance of a trade flow
            const flowIndex = Math.floor(Math.random() * tradeFlows.length);
            executeTradeFlow(tradeFlows[flowIndex]);
        } else {
            // Show a regular message
            const activityIndex = Math.floor(Math.random() * botActivities.length);
            const activity = botActivities[activityIndex];
            addLogMessage(activity.message, activity.type);
        }
    }, 8000); // Show a message roughly every 8 seconds
}

function stopSimulatedBotActivity() {
    if (botActivityInterval) {
        clearInterval(botActivityInterval);
        botActivityInterval = null;
    }
}

// Initialize WebSocket connection
function initWebSocket() {
    // Get host from current URL
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.host;
    const wsUrl = `${protocol}//${host}`;
    
    console.log(`Connecting to WebSocket at ${wsUrl}`);
    socket = new WebSocket(wsUrl);

    socket.onopen = () => {
        console.log('WebSocket Connected');
        document.getElementById('socketStatus').innerHTML = '🟢 Connected';
        document.getElementById('socketStatus').classList.remove('text-yellow-400');
        document.getElementById('socketStatus').classList.add('text-green-400');
        addLogMessage('Connected to server', 'success');
        
        // Start price simulation
        startPriceSimulation();
        
        // Initialize auto-consolidation tracking
        initializeAutoConsolidation();
        
        // Send health check every 30 seconds
        setInterval(() => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'health_check' }));
            }
        }, 30000);
    };

    socket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            handleWebSocketMessage(data);
        } catch (error) {
            console.error('WebSocket message error:', error);
            addLogMessage(`Error processing message: ${error.message}`, 'error');
        }
    };

    socket.onclose = () => {
        console.log('WebSocket Disconnected');
        document.getElementById('socketStatus').innerHTML = '🔴 Disconnected';
        document.getElementById('socketStatus').classList.remove('text-green-400');
        document.getElementById('socketStatus').classList.add('text-red-400');
        
        // Update bot status
        botStatus.textContent = 'Offline';
        botStatus.className = 'font-bold text-red-400';
        
        // Disable buttons
        startBotBtn.disabled = true;
        startBotBtn.classList.add('btn-disabled');
        stopBotBtn.disabled = true;
        stopBotBtn.classList.add('btn-disabled');
        
        // Add log message
        addLogMessage('Disconnected from server', 'error');
        
        // Attempt reconnection after 5 seconds
        setTimeout(initWebSocket, 5000);
    };
    
    socket.onerror = (error) => {
        console.error('WebSocket Error:', error);
        addLogMessage('Connection error', 'error');
    };
}

// Event Listeners
document.getElementById('connectWallet').addEventListener('click', () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'connect_wallet' }));
        addLogMessage('Connecting wallet...', 'info');
    } else {
        alert('WebSocket is not connected. Please wait for reconnection.');
        addLogMessage('Cannot connect wallet - server connection lost', 'error');
    }
});

document.getElementById('startBot').addEventListener('click', () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'start_bot' }));
        addLogMessage('Starting trading bot...', 'info');
    } else {
        alert('WebSocket is not connected. Please wait for reconnection.');
        addLogMessage('Cannot start bot - server connection lost', 'error');
    }
});

document.getElementById('stopBot').addEventListener('click', () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'stop_bot' }));
        addLogMessage('Stopping trading bot...', 'info');
    } else {
        alert('WebSocket is not connected. Please wait for reconnection.');
        addLogMessage('Cannot stop bot - server connection lost', 'error');
    }
});

document.getElementById('clearLog').addEventListener('click', () => {
    activityLog.innerHTML = '';
    addLogMessage('Log cleared', 'info');
});

// Add consolidate profits button event listener if it exists
const consolidateBtn = document.getElementById('consolidate-profits-btn');
if (consolidateBtn) {
    consolidateBtn.addEventListener('click', () => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'consolidate_profit' }));
            addLogMessage('Manually triggering profit consolidation...', 'consolidation');
        } else {
            alert('WebSocket is not connected. Please wait for reconnection.');
            addLogMessage('Cannot consolidate profits - server connection lost', 'error');
        }
    });
}

// Initialize WebSocket on page load
window.addEventListener('load', () => {
    initWebSocket();
    addLogMessage('Dashboard initialized', 'info');
    
    // Start with loading animations for prices
    for (const element of Object.values(priceElements)) {
        element.classList.add('animate-pulse');
    }
    
    // Initialize wallet balances and update UI
    updateBalances(walletBalances);
    
    // Calculate total SOL equivalent
    const totalSol = calculateTotalSolEquivalent(walletBalances);
    totalSolEquivalent.textContent = `${totalSol.toFixed(4)} SOL`;
    
    // Update profit display
    updateProfits();
    
    // Initialize auto-consolidated profits display
    if (autoConsolidatedEl) {
        if (!autoConsolidatedEl.dataset.amount) {
            autoConsolidatedEl.dataset.amount = "0";
        }
        autoConsolidatedEl.textContent = `${parseFloat(autoConsolidatedEl.dataset.amount).toFixed(6)} SOL`;
    }
    
    // Simulate connecting wallet (for demonstration)
    setTimeout(() => {
        document.getElementById('connectWallet').click();
    }, 2000);
});
    </script>
</body>
</html>